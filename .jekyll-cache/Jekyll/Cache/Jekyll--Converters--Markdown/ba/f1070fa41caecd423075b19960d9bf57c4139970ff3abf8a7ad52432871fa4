I"L+<p><em>해당 포스팅은 <a href="https://www.inflearn.com/course/iOS-Concurrency-GCD-Operation">iOS Concurrency(동시성) 프로그래밍, 동기 비동기 처리 그리고 GCD/Operation - 디스패치큐와 오퍼레이션큐의 이해</a> 강의를 수강하고 개인적으로 정리한 내용을 기록한 것 입니다.</em>
<br />
<br /></p>

<h2 id="디스패치-그룹의-개념">디스패치 그룹의 개념</h2>
<hr />

<p>디스패치 그룹은 여러 작업을 유사한 기준으로 묶어 묶인 작업이 끝나는 시기가 필요할 떄 사용한다.</p>

<p>다음의 코드처럼 사용할 수 있다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">group1</span> <span class="o">=</span> <span class="kt">DispatchGroup</span><span class="p">()</span>
<span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">(</span><span class="nv">qos</span><span class="p">:</span> <span class="p">)</span><span class="o">.</span><span class="nf">async</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 작업을 보낼 때 그룹 꼬리표를 붙여주는 느낌</span>
<span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">(</span><span class="nv">qos</span><span class="p">:</span> <span class="p">)</span><span class="o">.</span><span class="nf">async</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="nf">async</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">group1</span><span class="o">.</span><span class="nf">notify</span><span class="p">(</span><span class="nv">queue</span><span class="p">:</span> <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="p">){</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="k">in</span>
	<span class="c1">// 모든 작업이 끝났을 때 해당 클로저 실행</span>
	<span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">textLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"모든 작업이 완료되었습니다."</span>
<span class="p">}</span></code></pre></figure>

<p><br /></p>

<h3 id="동기적인-기다림">동기적인 기다림</h3>
<hr />

<p>어떤 이유로 그룹의 완료 알림에 비동기적으로 응답할 수 없는 경우, 대신 디스패치 그룹에서 <code class="language-plaintext highlighter-rouge">wait()</code> 메서드를 사용할 수 있다.<br />
모든 작업이 완료될 때까지 현재 대기열을 차단하는 동기적인 방법으로,<br />
작업이 완료될 때까지, 얼마나 오래 기다릴지 기다리는 시간을 지정하는 선택적 파라미터가 필요하다.<br />
기다리는 시간을 지정하지 않으면 무제한 대기한다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">group1</span> <span class="o">=</span> <span class="kt">DispatchGroup</span><span class="p">()</span>
<span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">(</span><span class="nv">qos</span><span class="p">:</span> <span class="p">)</span><span class="o">.</span><span class="nf">async</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">(</span><span class="nv">qos</span><span class="p">:</span> <span class="p">)</span><span class="o">.</span><span class="nf">async</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="nf">async</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">if</span> <span class="n">group1</span><span class="o">.</span><span class="nf">wait</span><span class="p">(</span><span class="nv">timeout</span><span class="p">:</span> <span class="o">.</span><span class="nf">now</span><span class="p">()</span><span class="o">+</span><span class="mi">60</span><span class="p">)</span> <span class="o">==</span> <span class="o">.</span><span class="n">timeOut</span> <span class="p">{</span>
	<span class="nf">print</span><span class="p">(</span><span class="s">"작업이 60초 안에 종료하지 않았습니다."</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>작업이 제때 끝나지 않았을 때 처리하기 유용하다.
<br />
<br />
<br /></p>

<h2 id="디스패치-그룹의-사용비동기-디스패치-그룹">디스패치 그룹의 사용(비동기 디스패치 그룹)</h2>
<hr />

<p>디스패치 그룹 클로저 내에서 비동기 함수를 호출할 때 주의가 필요하다. 내부에서 비동기적으로 다른 메서드를 큐로 보냈기 때문에 종료 시점이 잘못 인식될 수 있다.
종료 시점을 명확히 표기하기 위해 <code class="language-plaintext highlighter-rouge">enter()</code>, <code class="language-plaintext highlighter-rouge">leave()</code> 메서드를 통한 출입처리가 필요하다.</p>
<div style="text-align: center;">
	<img src="/images/20201115_9/1.png" width="80%" />
</div>
<p><br /></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">queue</span><span class="o">.</span><span class="nf">async</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group1</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">group1</span><span class="o">.</span><span class="nf">enter</span><span class="p">()</span> <span class="c1">// 입장</span>
	<span class="nf">someAsyncMethod</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">group1</span><span class="o">.</span><span class="nf">leave</span><span class="p">()</span> <span class="c1">// 퇴장</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br />
<br /></p>

<h2 id="dispatch-workitem">Dispatch workItem</h2>
<hr />

<ul>
  <li>작업을 미리 정의해두고 사용하는 큐에 제출하기 위한 객체(class)</li>
  <li>빈약한 취소 기능, 순서 기능을 내장하고 있다.</li>
</ul>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">item1</span> <span class="o">=</span> <span class="kt">DispatchWorkItem</span><span class="p">(</span><span class="nv">qos</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">print</span><span class="p">(</span><span class="s">"task1 출력"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">queue</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="s">"com.sbk.serial"</span><span class="p">)</span>
<span class="n">queue</span><span class="o">.</span><span class="nf">async</span><span class="p">(</span><span class="nv">execute</span><span class="p">:</span> <span class="n">item1</span><span class="p">)</span> <span class="c1">// 객체이므로 따로 실행해줘야 한다.</span></code></pre></figure>

<p><br />
<br /></p>

<h3 id="빈약한-취소-기능">빈약한 취소 기능</h3>

<p><code class="language-plaintext highlighter-rouge">cancel()</code> 내장 메서드를 갖고 있다.</p>
<ul>
  <li>작업이 아직 시작되지 않은 경우 작업을 제거한다.</li>
  <li>작업이 실행중인 경우 <code class="language-plaintext highlighter-rouge">isCancelled</code> 속성이 <code class="language-plaintext highlighter-rouge">true</code>로 설정된다. (직접적으로 실행 중인 작업이 멈추는 것은 아니다.)
<br />
<br /></li>
</ul>

<h3 id="빈약한-순서-기능">빈약한 순서 기능</h3>

<p><code class="language-plaintext highlighter-rouge">notify(queue: 실행할 큐, execute: 디스패치 아이템)</code> 내장 메서드를 갖고 있다.</p>
<ul>
  <li>다음에 실행할 아이템(작업)을 지정
<br />
<br />
<br /></li>
</ul>

<h2 id="semaphore">Semaphore</h2>
<hr />

<ul>
  <li>공유 리소스에 접근 가능한 작업 수를 제한해야 할 경우 사용한다.</li>
  <li>한 번에 실행하는 작업의 갯수를 제한한다.</li>
</ul>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">semaphore</span> <span class="o">=</span> <span class="kt">DispatchSemaphore</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">queue</span><span class="o">.</span><span class="nf">async</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group1</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">group1</span><span class="o">.</span><span class="nf">enter</span><span class="p">()</span>
	<span class="n">semaphore</span><span class="o">.</span><span class="nf">wait</span><span class="p">()</span> <span class="c1">// 일단 기다린다</span>
	<span class="n">someAsyncMethod</span> <span class="p">{</span>
		<span class="n">group1</span><span class="o">.</span><span class="nf">leave</span><span class="p">()</span>
		<span class="n">semaphore</span><span class="o">.</span><span class="nf">signal</span><span class="p">()</span> <span class="c1">//다음 작업 시작을 위한 시그널</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<hr />

<p><em>이미지 출처: <a href="https://www.inflearn.com/course/iOS-Concurrency-GCD-Operation"></a></em></p>
:ET